<!DOCTYPE html>
<html lang="zh">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Tree View</title>
  <style>
    body {
      margin: 0;
      background: linear-gradient(160deg, #1f232d, #2b2f3a 60%, #1a1d25);
      color: #f0f0f0;
      font-family: 'Segoe UI', sans-serif;
      overflow: hidden;
    }

    svg {
      width: 100%;
      height: 100vh;
    }

    .node circle {
      fill: url(#nodeGradient);
      stroke: #6fa3ef;
      stroke-width: 2px;
      cursor: pointer;
      transition: transform 0.25s ease, filter 0.25s ease;
      filter: drop-shadow(0 2px 6px rgba(0, 0, 0, 0.4));
      pointer-events: all;
    }

    .node circle:hover {
      fill: url(#nodeHoverGradient);
      stroke: #ffffff;
      transform: scale(1.12);
      filter: drop-shadow(0 4px 12px rgba(111, 163, 239, 0.8));
    }

    .node:active circle {
      transform: scale(0.9);
      filter: drop-shadow(0 2px 8px rgba(255, 255, 255, 0.6));
    }

    .node text {
      fill: #ffffff;
      font-size: 13px;
      font-weight: 500;
      text-shadow: 0 1px 3px rgba(0, 0, 0, 0.8);
      pointer-events: none;
    }

    .lock {
      font-size: 16px;
      pointer-events: none;
    }

    .link {
      fill: none;
      stroke: url(#linkGradient);
      stroke-width: 2.5px;
      opacity: 0.85;
      filter: drop-shadow(0 0 3px rgba(111, 163, 239, 0.4));
    }

    g.node,
    path.link {
      animation: fadeIn 0.8s ease forwards;
      opacity: 0;
    }

    #backbtn {
      position: absolute;
      top: 20px;
      left: 20px;
      padding: 8px 16px;
      font-size: 14px;
      background-color: #4a90e2;
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      transition: background-color 0.3s ease;
      z-index: 10;
    }

    #backbtn:hover {
      background-color: #357ab8;
    }

    @keyframes fadeIn {
      to {
        opacity: 1;
      }
    }
  </style>
</head>

<body>
  <button id="backbtn">‚Üê</button>
  <svg></svg>
  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
  <script>
    const vscode = acquireVsCodeApi();
    const graph = {
      nodes: [
        { id: 'ÁºñÁ®ãËØ≠Ë®ÄÂü∫Á°Ä', url: 'page1', unlocked: true, completed: false },
        { id: 'Âü∫Êú¨Êï∞ÊçÆÁ±ªÂûã', url: 'page2', unlocked: false, completed: false },
        { id: 'Âü∫Êú¨ËøêÁÆó', url: 'page3', unlocked: false, completed: false },
        { id: 'Á®ãÂ∫èÂü∫Êú¨ËØ≠Âè•', url: 'page4', unlocked: false, completed: false },
        { id: 'Êï∞ÁªÑ‰∏éÂ≠óÁ¨¶‰∏≤', url: 'page5', unlocked: false, completed: false },
        { id: 'ÊåáÈíà‰∏éÂºïÁî®', url: 'page6', unlocked: false, completed: false },
        { id: 'ÁªìÊûÑ‰Ωì', url: 'page7', unlocked: false, completed: false },
        { id: 'Êñá‰ª∂ËØªÂÜô', url: 'page8', unlocked: false, completed: false },
        { id: 'ÂáΩÊï∞‰∏éÈÄíÂΩí', url: 'page9', unlocked: false, completed: false },
        { id: 'Êï∞ÊçÆÂ∫ìÂ∏∏Áî®ÂáΩÊï∞', url: 'page10', unlocked: false, completed: false }
      ],
      links: [
        { source: 'ÁºñÁ®ãËØ≠Ë®ÄÂü∫Á°Ä', target: 'Âü∫Êú¨Êï∞ÊçÆÁ±ªÂûã' },
        { source: 'Âü∫Êú¨Êï∞ÊçÆÁ±ªÂûã', target: 'Âü∫Êú¨ËøêÁÆó' },
        { source: 'Âü∫Êú¨ËøêÁÆó', target: 'Á®ãÂ∫èÂü∫Êú¨ËØ≠Âè•' },
        { source: 'Á®ãÂ∫èÂü∫Êú¨ËØ≠Âè•', target: 'Êï∞ÁªÑ‰∏éÂ≠óÁ¨¶‰∏≤' },
        { source: 'Êï∞ÁªÑ‰∏éÂ≠óÁ¨¶‰∏≤', target: 'ÊåáÈíà‰∏éÂºïÁî®' },
        { source: 'ÊåáÈíà‰∏éÂºïÁî®', target: 'ÁªìÊûÑ‰Ωì' },
        { source: 'ÊåáÈíà‰∏éÂºïÁî®', target: 'Êñá‰ª∂ËØªÂÜô' },
        { source: 'Á®ãÂ∫èÂü∫Êú¨ËØ≠Âè•', target: 'ÂáΩÊï∞‰∏éÈÄíÂΩí' },
        { source: 'ÂáΩÊï∞‰∏éÈÄíÂΩí', target: 'Êï∞ÊçÆÂ∫ìÂ∏∏Áî®ÂáΩÊï∞' }
      ]
    };

    function updateUnlockStatus() {
      graph.nodes.forEach(node => {
        if (!node.unlocked) {
          const predecessors = graph.links.filter(l => l.target.id === node.id).map(l => l.source);
          if (predecessors.length > 0 && predecessors.every(p => p.completed)) {
            node.unlocked = true;
          }
        }
      })
    }
    const svg = d3.select('svg')
      .attr('preserveAspectRatio', 'xMidYMid meet')
      .attr('viewBox', `0 0 ${window.innerWidth} ${window.innerHeight}`);

    const defs = svg.append("defs");
    defs.html(`
    <linearGradient id="nodeGradient" x1="0" y1="0" x2="0" y2="1">
      <stop offset="0%" stop-color="#4a90e2" />
      <stop offset="100%" stop-color="#357ab8" />
    </linearGradient>
    <linearGradient id="nodeHoverGradient" x1="0" y1="0" x2="0" y2="1">
      <stop offset="0%" stop-color="#6fa3ef" />
      <stop offset="100%" stop-color="#4a90e2" />
    </linearGradient>
    <linearGradient id="linkGradient" x1="0" y1="0" x2="1" y2="0">
      <stop offset="0%" stop-color="#6fa3ef" />
      <stop offset="100%" stop-color="#4a90e2" />
    </linearGradient>
  `);
    function animateUnlock(fromNode, toNode) {
      const link = svg.selectAll('.link')
        .filter(d => d.source.id === fromNode.id && d.target.id === toNode.id);
      link.attr("stroke-dasharray", function () {
        return this.getTotalLength();
      })
        .attr("stroke-dashoffset", function () {
          return this.getTotalLength();
        })
        .transition()
        .duration(800)
        .attr("stroke-dashoffset", 0)
        .attr("stroke-width", 4)
        .transition()
        .duration(200)
        .attr("stroke-width", 2)
        .style("filter", "drop-shadow(0 0 3px rgba(111, 163, 239, 0.4))")
        .on("end", function () {
          toNode.unlocked = true;
          render(false);
        });
    }

    function render(initial = false) {
      const width = window.innerWidth;
      const height = window.innerHeight;
      svg.attr('viewBox', `0 0 ${width} ${height}`);

      console.log('Rendering graph with dimensions:', width, height);
      const nodeMap = {};
      graph.nodes.forEach(n => nodeMap[n.id] = n);
      graph.links.forEach(l => {
        if (!nodeMap[l.source]) {
          l.source = nodeMap[l.source.id];
          l.target = nodeMap[l.target.id];
        }
        else {
          l.source = nodeMap[l.source];
          l.target = nodeMap[l.target];
        }
      });

      // BFS ÂàÜÂ±Ç
      const levels = {};
      const start = nodeMap['ÁºñÁ®ãËØ≠Ë®ÄÂü∫Á°Ä'];
      const queue = start ? [start] : [];
      if (start) levels[start.id] = 0;
      while (queue.length) {
        const node = queue.shift();
        const level = levels[node.id];
        graph.links.forEach(l => {
          if (l.source.id === node.id && levels[l.target.id] === undefined) {
            levels[l.target.id] = level + 1; queue.push(l.target);
          }
        });
      }

      let maxLevel = Math.max(...Object.values(levels));
      graph.nodes.forEach(n => {
        if (levels[n.id] === undefined) {
          levels[n.id] = ++maxLevel;
        }
      });

      const layers = {};
      for (const id in levels) {
        const lvl = levels[id];
        if (!layers[lvl]) layers[lvl] = [];
        layers[lvl].push(nodeMap[id]);
      }

      const nodeSize = 44;
      //const layerGap = Math.max(80, Math.min(200, height / (maxLevel + 2)));
      const layerGap = Math.min(200, height / (maxLevel + 2));
      const marginX = 60;
      const usableWidth = width - marginX * 2;

      //ÂàÜÈÖçÊØè‰∏™ËäÇÁÇπÁöÑ‰ΩçÁΩÆ
      for (const lvl in layers) {
        const arr = layers[lvl];
        const count = arr.length;
        arr.forEach((n, i) => {
          n.x = marginX + (i + 0.5) * (usableWidth / count);
          n.y = height - 80 - lvl * layerGap;
        });
      }

      //ËÆæÁΩÆÈó¥Ë∑ù
      if (initial) {
        // ÁîªËøûÁ∫ø
        svg.append("g").attr("class", "links")
          .selectAll("path")
          .data(graph.links)
          .enter()
          .append("path")
          .attr("class", "link")
          .attr("d", d => {
            const sx = d.source.x, sy = d.source.y;
            const tx = d.target.x, ty = d.target.y;
            let midX = (sx + tx) / 2;
            if (sx === tx) {
              midX += 0.01;
            }
            return `M${sx},${sy} C${midX},${sy} ${midX},${ty} ${tx},${ty}`;
          });

        // ÁîªËäÇÁÇπ
        const node = svg.append("g").attr("class", "nodes")
          .selectAll("g")
          .data(graph.nodes)
          .enter()
          .append("g")
          .attr("class", "node")
          .attr("transform", d => `translate(${d.x},${d.y})`);

        // ÁÇπÂáªÂå∫ÂüüÔºàÊîæÂú®ÊúÄ‰∏äÂ±ÇÔºâ
        /*node.append("circle")
          .attr("r", nodeSize / 2 + 6)
          .attr("fill", "transparent")
          .style("cursor", "pointer")
          .on("click", (event, d) => {
            vscode.postMessage({ type: 'navigate', url: d.url });
          });*/

        // ËßÜËßâÂúÜ
        node.append("circle")
          .attr("r", nodeSize / 2)
          .style("fill", d => d.unlocked ? "url(#nodeGradient)" : "#555")
          .style("stroke", d => d.completed ? "#00ff99" : "#6fa3ef")
          .style("cursor", d => d.unlocked ? "pointer" : "not-allowed")
          .on("click", (event, d) => {
            /*if (d.unlocked) {
              vscode.postMessage({ type: 'navigate', url: d.url });
            }*/
            if (!d.unlocked) return;
            d.completed = true;
            render(false);
            const lastCompletedNode = d;
            const successors = graph.links.filter(l => l.source.id === d.id).map(l => l.target);
            successors.forEach(toNode => {
              const predecessors = graph.links.filter(l => l.target.id === toNode.id).map(l => l.source);
              if (predecessors.every(p => p.completed)) {
                animateUnlock(lastCompletedNode, toNode);
              }
            })
            //updateUnlockStatus();
            vscode.postMessage({ type: 'navigate', url: d.url });
          });

        node.append("text")
          .attr("text-anchor", "middle")
          .attr("dy", ".35em")
          .text(d => d.id);
        node.filter(d => !d.unlocked)
          .append("text")
          .attr("class", "lock")
          .attr("text-anchor", "middle")
          .attr("dy", ".35em")
          .text("üîí");
      }
      else {
        svg.selectAll(".link")
          .data(graph.links)
          .transition()
          .duration(800)
          .attr("d", d => {
            const sx = d.source.x, sy = d.source.y;
            const tx = d.target.x, ty = d.target.y;
            let midX = (sx + tx) / 2;
            if (sx === tx) {
              midX += 0.01;
            }
            return `M${sx},${sy} C${midX},${sy} ${midX},${ty} ${tx},${ty}`;
          });
        svg.selectAll(".node")
          .data(graph.nodes)
          .transition()
          .duration(800)
          .attr("transform", d => `translate(${d.x},${d.y})`);
        svg.selectAll(".node circle")
          .data(graph.nodes)
          .transition()
          .duration(500)
          .style("fill", d => d.unlocked ? "url(#nodeGradient)" : "#555")
          .style("stroke", d => d.completed ? "#00ff99" : "#6fa3ef")
          .style("cursor", d => d.unlocked ? "pointer" : "not-allowed");

        svg.selectAll(".lock").remove();
        svg.selectAll(".node")
          .filter(d => !d.unlocked)
          .append("text")
          .attr("class", "lock")
          .attr("text-anchor", "middle")
          .attr("dy", ".35em")
          .text("üîí");
      }
    }

    render(true);
    window.addEventListener('resize', () => render(false));
    document.getElementById('backbtn').addEventListener('click', () => {
      vscode.postMessage({ type: 'goBack' });
    })
  </script>
</body>

</html>